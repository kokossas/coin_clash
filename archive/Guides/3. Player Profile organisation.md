Here’s a focused guide on **Player Profile Handling & Economic Updates**, explaining where player data lives, how it’s manipulated, and how the economic flows tie into the game logic. It’s organized so that a new developer can trace and safely modify any of these behaviors without breaking existing functionality.

---

## 1. Project Organization (Relevant to Player Profiles)

```
.
├── __main__.py              # Entry-point: wires repos, config, and MatchEngine
├── config.yaml              # All economic parameters (fees, rates, cuts)
├── core/
│   ├── models.py            # ORM definitions (Player, Character, Match, etc.)
│   ├── repositories.py      # Abstract and SQLite implementations of PlayerRepo, etc.
│   ├── engine.py            # MatchEngine: drives rounds, applies events, does payouts
│   ├── config_loader.py     # Loads config.yaml
│   ├── scenario_loader.py   # Loads JSON scenarios into memory
│   └── utils.py             # Helpers: name generator, seedable RNG
├── data/coin_clash.db       # SQLite database backing Player & inventory persistence
└── scenarios/…              # Event text JSON files (affecting stats/inventory)
```

This layout cleanly separates:

* **Data models & persistence** (`core/models.py` + `core/repositories.py`)
* **Game flow & economic logic** (`__main__.py` + `core/engine.py`)
* **Configuration & content** (`config.yaml`, `scenarios/`)

---

## 2. Player Profile: Data Model & Relationships

### 2.1 `Player` Model

Defined in **`core/models.py`**, `Player` holds all per-user state:

```python
class Player(Base):
    __tablename__ = "players"
    id                = Column(Integer, primary_key=True)
    username          = Column(String, unique=True, nullable=False)
    balance           = Column(Float, default=0.0)
    wins              = Column(Integer, default=0)
    kills             = Column(Integer, default=0)
    total_sui_earned  = Column(Float, default=0.0)
    created_at        = Column(DateTime, server_default=func.now())

    characters = relationship("Character", back_populates="player_owner")
    inventory  = relationship("PlayerItem", back_populates="player")
```

* **`balance`**: current SUI balance.
* **`wins`, `kills`, `total_sui_earned`**: aggregate stats used for leaderboards or cosmetics.&#x20;

### 2.2 `PlayerItem` (Inventory)

Represents how many of each `Item` a player holds:

```python
class PlayerItem(Base):
    __tablename__ = "player_items"
    player_id = Column(Integer, ForeignKey("players.id"), primary_key=True)
    item_id   = Column(Integer, ForeignKey("items.id"),   primary_key=True)
    quantity  = Column(Integer, default=1)
    acquired_at = Column(DateTime, server_default=func.now())
    …
```

Cosmetics or gear found during play are added here .

---

## 3. Repository Layer: `PlayerRepo` API

All database interactions go through `PlayerRepo` (and its concrete `SqlPlayerRepo`), ensuring isolation of persistence logic . Key methods:

| Method                                                  | Purpose                               |
| ------------------------------------------------------- | ------------------------------------- |
| `get_or_create_player(username)`                        | Look up or insert a new `Player`.     |
| `update_player_balance(player_id, amount_change)`       | Add (or subtract) SUI from `balance`. |
| `add_win(player_id)`                                    | Increment `wins`.                     |
| `add_kill(player_id)`                                   | Increment `kills`.                    |
| `add_sui_earned(player_id, amount)`                     | Increment `total_sui_earned`.         |
| `get_player_inventory(player_id)`                       | List all `PlayerItem`s.               |
| `add_item_to_inventory(player_id, item_id, quantity=1)` | Add or bump an item in inventory.     |

**Modifying behaviors** (e.g. logging each balance update to an audit table) is as simple as extending or decorating these methods without touching game-flow code.

---

## 4. Economic Flows in Game Logic

### 4.1 Entry Fees & Protocol Cut

In `__main__.py`’s `simulate_character_purchases(...)`, for each player:

1. **Determine** how many characters to buy (1–3 by default).
2. **Compute**

   * `total_cost = num_chars × entry_fee`
   * `cut_amount = total_cost × protocol_cut_rate` (10%, 8%, 6% tiers)
   * `net_fee_to_pool = total_cost − cut_amount`
3. **(Stub)** Deduct from player via

   ```python
   # player_repo.update_player_balance(player.id, -total_cost)
   ```
4. **Accumulate** totals for prize-pool logic .

> **To enable real fee‐checks**: uncomment and validate `update_player_balance` returns non-negative before character creation.

### 4.2 Kill-Award Payouts

* **Configured** in `config.yaml` (`kill_award_rate_default: 0.1`) .
* During **lethal events**, after determining a kill, you should call:

  ```python
  player_repo.add_kill(killer_id)
  player_repo.update_player_balance(killer_id, entry_fee × kill_award_rate)
  player_repo.add_sui_earned(killer_id, entry_fee × kill_award_rate)
  ```

  *Note: The current stub logs kill events but does not yet award per-kill payouts—this is the spot to plug in those calls.*

### 4.3 Final Winner Payout

At match-end in `MatchEngine.run_match()`:

1. **`add_win`** for the winner.
2. **`_calculate_payouts`** computes `(protocol_cut, total_kill_awards, winner_payout)`.
3. **Award SUI** via:

   ```python
   player_repo.add_sui_earned(winner_id, winner_payout)
   player_repo.update_player_balance(winner_id, winner_payout)
   ```
4. **Persist** winner character on `Match` record.&#x20;

---

## 5. Stats & Inventory Hooks

* **Kills & Wins**: tracked via `add_kill` / `add_win`.
* **Total SUI Earned**: updated on each payout via `add_sui_earned`.
* **Item Finds** (non-lethal story events): in `MatchEngine._process_event`, after logging an “item\_find” or similar event, call

  ```python
  item_repo.add_item_to_inventory(player_id, item_id)
  ```

  and update DB. This ensures cosmetics persist across matches .

---

## 6. Character Ownership & Naming

* **`Character` Model** links back to `Player` via `owner_username` and carries `is_alive` state .
* **Sequential Naming** is done via `get_next_character_name()` in `core/utils.py`; can be swapped for any naming strategy without touching engine logic.

---

## 7. Validation Checklist

Before handing off or extending:

* **Model Changes**: if adding fields to `Player`, update both `models.py` **and** any affected repo methods.
* **Economic Parameters**: adjust `config.yaml`—all currency logic reads from config.
* **Persistence**: all state changes must go through repo methods; avoid raw SQL in engine.
* **Tests**: any change to fee or reward logic should be covered by unit tests around:

  * Entry-fee charging
  * Kill-award payouts
  * Winner payout rounding
  * Inventory additions

This guide ensures you can locate, understand, and modify any part of the player-economy pipeline—from DB schema to in-match awarding—without side-effects on unrelated game logic.
