Here’s a focused guide to the project’s **Database Interaction** layer—how game data (players, characters, matches, events, items) is modeled, stored, and managed so you can confidently make changes without breaking existing functionality.

---

## Database Setup

* **Initialization**

  * The SQLite database is created (if missing) by calling `init_db()` from **models.py**, which invokes SQLAlchemy’s `Base.metadata.create_all(...)`.
  * This is already wired to run on import of the repositories module, so your DB file will exist once you start the app or run any repo code .

* **Location / Configuration**

  * The connection URL is hard-coded in **models.py** as

    ```python
    DATABASE_URL = "sqlite:////home/ubuntu/coin_clash/data/coin_clash.db"
    ```
  * If you need to point at a different path or switch to another database engine, update this constant (or refactor to load from `config.yaml`).

* **Session Management**

  * A `SessionLocal = sessionmaker(...)` is bound to the engine in **models.py**.
  * The helper `get_db()` in **repositories.py** is a generator that yields a session and ensures it’s closed after use .

---

## ORM Models

All tables inherit from `Base = declarative_base()`. Relationships between them map to SQL foreign keys, so ORM queries can span objects naturally.

### 1. `players`

| Column             | Type     | Notes                                                       |
| ------------------ | -------- | ----------------------------------------------------------- |
| `id`               | Integer  | Primary key                                                 |
| `username`         | String   | Unique, non-null                                            |
| `balance`          | Float    | Player’s currency balance                                   |
| `wins`             | Integer  | Total matches won                                           |
| `kills`            | Integer  | Total kills                                                 |
| `total_sui_earned` | Float    | Cumulative awards earned                                    |
| `created_at`       | DateTime | Auto-set to now                                             |
| **Relationships**  |          | `characters` (their owned Characters), `inventory` (items)  |

### 2. `characters`

| Column            | Type     | Notes                                  |
| ----------------- | -------- | -------------------------------------- |
| `id`              | Integer  | Primary key                            |
| `name`            | String   | E.g. “Warrior”, “Mage”                 |
| `owner_username`  | String   | FK → `players.username`                |
| `match_id`        | Integer  | FK → `matches.id`, null until assigned |
| `is_alive`        | Integer  | 1 = alive, 0 = dead                    |
| `created_at`      | DateTime | Auto-set                               |
| **Relationships** |          | `player_owner`, `match`                |

### 3. `matches`

| Column                | Type     | Notes                                               |
| --------------------- | -------- | --------------------------------------------------- |
| `id`                  | Integer  | Primary key                                         |
| `entry_fee`           | Float    | Fee per character                                   |
| `kill_award_rate`     | Float    | % of entry\_fee paid per kill                       |
| `start_method`        | String   | “cap” or “timeout”                                  |
| `start_threshold`     | Integer  | Cap size or timeout seconds                         |
| `start_timestamp`     | DateTime | When match went “active”                            |
| `end_timestamp`       | DateTime | When match completed                                |
| `winner_character_id` | Integer  | FK → `characters.id`, null until declared           |
| `status`              | String   | “pending” / “active” / “completed”                  |
| `created_at`          | DateTime | Auto-set                                            |
| **Relationships**     |          | `participants` (Characters), `events` (MatchEvent)  |

### 4. `match_events`

| Column                   | Type     | Notes                                    |
| ------------------------ | -------- | ---------------------------------------- |
| `id`                     | Integer  | Primary key                              |
| `match_id`               | Integer  | FK → `matches.id`                        |
| `round_number`           | Integer  | Round in which this event occurred       |
| `event_type`             | String   | Category (“direct\_kill”, “story”, etc.) |
| `scenario_source`        | String   | File ID or “generated”                   |
| `scenario_text`          | Text     | Fully substituted text                   |
| `affected_character_ids` | String   | CSV of Character IDs                     |
| `timestamp`              | DateTime | Auto-set                                 |
| **Relationships**        |          | `match`                                  |

### 5. `items`

| Column               | Type    | Notes                                   |
| -------------------- | ------- | --------------------------------------- |
| `id`                 | Integer | Primary key                             |
| `name`               | String  | Unique                                  |
| `type`               | String  | Cosmetic, gear, consumable              |
| `rarity`             | String  | Common, rare, legendary                 |
| `description`        | Text    | Free text                               |
| `on_find_hook_info`  | String? | Metadata for find-time hook (optional)  |
| `on_award_hook_info` | String? | Metadata for award-time hook (optional) |
| **Relationships**    |         | `player_items`                          |

### 6. `player_items` (join table)

| Column            | Type     | Notes                                   |
| ----------------- | -------- | --------------------------------------- |
| `player_id`       | Integer  | FK → `players.id`, part of composite PK |
| `item_id`         | Integer  | FK → `items.id`, part of composite PK   |
| `quantity`        | Integer  | Count                                   |
| `acquired_at`     | DateTime | Auto-set                                |
| **Relationships** |          | `player`, `item`                        |

---

## Repositories & Session Usage

All DB interactions go through **Repository** classes—this decouples SQLAlchemy from business logic and makes unit-testing easier.

* **`BaseRepo`**

  * Holds a `self.db: Session`
  * Concrete repos inherit common patterns (add, get, commit, refresh) .

* **`SqlPlayerRepo`**

  * CRUD for `Player` (create, fetch by username, update balance, wins, kills, earned SUI).
  * Inventory methods: `get_player_inventory()`, `add_item_to_inventory()` .

* **`SqlCharacterRepo`**

  * `create_character(name, owner_username)`
  * Assign to match, mark dead/alive, and query by player or match.

* **`SqlMatchRepo`**

  * `create_match(...)` – new match record
  * `update_match_status(id, status)`, `set_match_start_time()`, `set_match_end_time()`, `set_match_winner()` .

* **`SqlEventRepo`**

  * `create_match_event(...)` – logs each event during simulation
  * `get_events_for_match(match_id)` to replay or analyze.

* **`SqlItemRepo`**

  * `get_item_by_name()`, `create_item()`, `get_all_items()`.

* **Session injection**

  * In **`__main__.py`**, `db_session = next(get_db())`
  * Repos built with `SqlXRepo(db_session)` in `setup_repositories()` and passed into the engine .
  * At the end of simulation the session is closed.

---

## How the Engine Uses the DB

Within **`MatchEngine`** (in `engine.py`):

1. **Match lifecycle**

   * `match_repo.update_match_status(..., "active")` & `match_repo.set_match_start_time()`
   * After rounds: `set_match_winner()`, `update_match_status(..., "completed")`, `set_match_end_time()` .

2. **Event logging**

   * Each round’s outcome is saved via `event_repo.create_match_event(...)`, capturing text, round, effected characters .

3. **Player economics & stats**

   * On a kill: `player_repo.add_kill()`, calculate payout = `entry_fee * kill_award_rate`, then (stub) award SUI and—once implemented—call `player_repo.update_player_balance()` and `player_repo.add_sui_earned()`.
   * On match win: similarly compute and call `add_sui_earned()` + `update_player_balance()`, and `add_win()` .

4. **Character status**

   * Elimination calls `character_repo.kill_character()` (or equivalent) to set `is_alive=0` and `match_id` association.

---

## Making Safe Modifications

* **Schema changes**

  * Update the model in **`models.py`** (e.g. add a column).
  * Add corresponding methods in the repo interface and its `Sql…` implementation.
  * Run `init_db()` or use migrations (not yet integrated).

* **Adding new stats**

  * Extend the `Player` model with new fields (e.g. `assists`).
  * Provide repo methods to update/query them.
  * Hook into `MatchEngine` where appropriate.

* **Leaderboards / Queries**

  * Build new repo methods for ranking, e.g.:

    ```python
    def get_top_players_by_wins(self, limit=10):
        return self.db.query(Player).order_by(Player.wins.desc()).limit(limit).all()
    ```
  * Expose via your bot or API layer as needed.

* **Switching DB engines**

  * Refactor `DATABASE_URL` into `config.yaml` and reload in `models.py`.
  * Ensure sessions and repos still use the updated URL.

---

This structure keeps all SQL concerns isolated in **`models.py`** and **`repositories.py`**, with **`MatchEngine`** driving logic via those clean interfaces. You can now confidently extend fields, add new tables (e.g. achievements), or tweak economic rules knowing where and how data flows through the system.
