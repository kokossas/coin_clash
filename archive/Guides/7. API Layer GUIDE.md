Here’s a guide focused on introducing an **API layer**—a thin intermediary between the core game logic and any future UI (e.g. a Telegram bot)—so that newcomers can safely hook in new features or objectives without touching the engine itself.

---

## 1. Project Structure & Core Responsibilities

At a high level, **Coin Clash** is organized like this:

```
.
├── __main__.py            # standalone simulation entrypoint
├── config.yaml            # all tunable parameters (fees, weights, etc.)
├── core/                  # pure-Python “engine” modules
│   ├── config_loader.py   # reads config.yaml into a dict
│   ├── utils.py           # seedable RNG, name generators, misc helpers
│   ├── models.py          # SQLAlchemy ORM definitions (Player, Character, Match, etc.)
│   ├── repositories.py    # abstract + SQLite repos (PlayerRepo, MatchRepo, ...)
│   ├── scenario_loader.py # loads JSON scenario pools by category
│   └── engine.py          # `MatchEngine`: the full match flow :contentReference[oaicite:0]{index=0}:contentReference[oaicite:1]{index=1}
├── scenarios/             # JSON files for each event category :contentReference[oaicite:2]{index=2}:contentReference[oaicite:3]{index=3}
│   ├── direct_kill.json
│   ├── self.json
│   └── …  
└── tests/                 # (empty) placeholder for unit tests
```

* **config\_loader.py**: single function `load_config()` returns all parameters (fees, event‐weights, thresholds) .
* **scenario\_loader.py**: `load_scenarios()` returns a dict of lists of scenario texts, keyed by category.
* **models.py** & **repositories.py**: define DB models and abstract repositories plus SQL implementations for persistence (players, matches, events, items) .
* **engine.py**: central `MatchEngine` class orchestrates rounds: sampling event types, picking scenarios, placeholder substitution, applying kills/resurrections, logging via `EventRepo`, payout calculation, and match lifecycle (`pending → active → completed`) .
* ****main**.py**: example script showing how to wire up `load_config()`, repos, simulate purchases, and call `MatchEngine.run_match()` .

---

## 2. Why an API Layer?

* **Separation of Concerns**: Keep UI code (Telegram, web, CLI) completely separate from core logic.
* **Stable Contract**: Define a small set of service methods; core can evolve internally without breaking adapters.
* **Dependency Injection**: Pass in config, repos, RNG, etc., so you can swap or mock for tests or different backends.
* **DTOs & Validation**: Convert raw DB models into plain data objects for UI; centralize input checks.

---

## 3. Designing the API Layer

### 3.1. Location & Structure

Create a new module, e.g.:

```
coin_clash/
└── api/
    └── game_service.py
```

### 3.2. Core Service Class

```python
# coin_clash/api/game_service.py

from typing import List, Dict, Any
from core.repositories import PlayerRepo, CharacterRepo, MatchRepo, EventRepo, ItemRepo
from core.engine import MatchEngine
from core.config_loader import load_config
from core.scenario_loader import load_scenarios
from core.utils import SeedableRandom

class GameService:
    def __init__(
        self,
        player_repo: PlayerRepo,
        character_repo: CharacterRepo,
        match_repo: MatchRepo,
        event_repo: EventRepo,
        item_repo: ItemRepo,
        seed: int = None
    ):
        self.config = load_config()
        self.scenarios = load_scenarios()
        self.random = SeedableRandom(seed)
        self.player_repo = player_repo
        self.character_repo = character_repo
        self.match_repo = match_repo
        self.event_repo = event_repo
        self.item_repo = item_repo

    def create_match(self, entry_fee: float, kill_award_rate: float,
                     start_method: str, start_threshold: int) -> int:
        match = self.match_repo.create_match(entry_fee, kill_award_rate,
                                             start_method, start_threshold)
        return match.id

    def purchase_characters(self, match_id: int,
                            username: str, count: int) -> List[int]:
        """Charge entry fee, create Character records, assign to match."""
        # 1. Fetch or create player
        player = self.player_repo.get_or_create_player(username)
        # 2. Calculate fee & protocol cut per config
        # 3. Update player balance stub or real
        # 4. Loop count times:
        #      name = get_next_character_name()
        #      char = self.character_repo.create_character(name, username)
        #      self.character_repo.assign_character_to_match(char.id, match_id)
        #      collect char.id
        # 5. Return list of character IDs
        …
    
    def start_match(self, match_id: int, participants: List[int]) -> Dict[str, Any]:
        """
        Instantiates MatchEngine, runs the match, returns dict:
        { "winner": { … }, "events": [ … ], "payouts": { … } }
        """
        engine = MatchEngine(
            match_id=match_id,
            config=self.config,
            scenarios=self.scenarios,
            player_repo=self.player_repo,
            character_repo=self.character_repo,
            match_repo=self.match_repo,
            event_repo=self.event_repo,
            item_repo=self.item_repo,
            random_seed=self.random.seed
        )
        winner_char, log = engine.run_match(participants)
        # Map winner_char → player info, payouts, etc.
        return {
            "winner": {
                "character_id": winner_char.id,
                "display_name": winner_char.display_name,
                "owner": winner_char.owner_username
            },
            "log": log
        }

    def get_match_events(self, match_id: int) -> List[Dict[str, Any]]:
        """Fetch all logged events for UI display."""
        events = self.event_repo.get_events_for_match(match_id)
        # Convert ORM to dicts
        return [ { "round": e.round_number, "text": e.scenario_text, … } for e in events ]
```

> Notice how **GameService** never deals with sockets, Telegram updates, or JSON marshalling. It purely wraps core logic .

---

## 4. Integrating with a Telegram Bot

1. **Dependency Setup**

   ```python
   from core.repositories import SessionLocal, SqlPlayerRepo, …
   from api.game_service import GameService

   db = SessionLocal()
   repos = {
     "player": SqlPlayerRepo(db),
     "character": SqlCharacterRepo(db),
     …
   }
   service = GameService(**repos, seed=42)
   ```
2. **Bot Handlers**

   * **/start\_match** → call `service.create_match(...)` → reply “Match #42 created.”
   * **/buy 2** → take username from update, call `service.purchase_characters(42, user, 2)` → reply with character IDs.
   * **/run** → call `service.start_match(42, [list of char IDs])` → stream back `log` lines one by one or as a batch.
   * **/events** → call `service.get_match_events(42)` → format for chat.

Because all domain logic lives in `core/`, handlers remain trivial.

---

## 5. Best Practices & Extensions

* **Dependency Injection** enables injecting mock repos for unit tests.
* **DTO Layer** (e.g. Pydantic models) can sit between `GameService` and UI for validation.
* **Versioning**: Keep the service interface stable; if core logic changes, adapt only `game_service.py`.
* **New Objectives**: Adding a new “tournament” flow or alternate economy simply means adding methods to the API layer—core engine remains untouched.
* **Testing**: Write unit tests against `GameService` methods using in-memory SQLite or mock repos.

---

## 6. Completeness Checklist

* [x] **Configuration**: all fees, weights, thresholds loaded once in service&#x20;
* [x] **Scenario Pools**: categorised JSON → `scenarios` dict&#x20;
* [x] **Player & Character Management**: repos abstract persistence&#x20;
* [x] **Match Flow**: start, rounds, payout, end handled by `MatchEngine`&#x20;
* [x] **Logging & Events**: stored via `EventRepo`, retrievable for UI
* [x] **Randomness**: seedable for reproducibility via `SeedableRandom`&#x20;
* [x] **Entry-Point Isolation**: `__main__.py` used only for CLI/testing&#x20;

With this API‐layer guide, a new developer can immediately see where to hook UI code, where to grow new features, and how to preserve the integrity of the existing game logic.
