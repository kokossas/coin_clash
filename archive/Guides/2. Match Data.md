Below is a focused guide to the **match data** in Coin Clash—how it’s defined in the ORM, managed by repositories, and driven through the engine—so that a new developer can confidently adapt match logic without breaking existing structure.

---

## 1. Data Models (core/models.py)

1. **Match**

   * **Table**: `matches`
   * **Key fields**:

     * `id` – primary key
     * `entry_fee`, `kill_award_rate` – per-match economic settings
     * `start_method` (“cap” or “timeout”), `start_threshold` – when to fire off the match
     * `start_timestamp`, `end_timestamp` – persisted lifecycle markers
     * `winner_character_id` – FK to winning `Character`
     * `status` (pending → active → completed)
   * **Relationships**:

     * `participants` – all `Character` in this match
     * `events` – all `MatchEvent` rows for logging rounds&#x20;

2. **MatchEvent**

   * **Table**: `match_events`
   * **Key fields**:

     * `id`, `match_id`, `round_number`
     * `event_type` (e.g. direct\_kill, comeback…)
     * `scenario_source`, `scenario_text` – reference to the sampled scenario
     * `affected_character_ids` – comma-separated IDs of victims/resurrectees
     * `timestamp` – when logged
   * **Backref**: `match.events`&#x20;

3. **Character**

   * **Table**: `characters`
   * Fields include `id`, `name`, `owner_username` (FK → Player), `match_id` (FK → Match), and `is_alive` flag
   * Used as the unit of participation; belongs to one `Match` at a time&#x20;

---

## 2. Repository Layer (core/repositories.py)

Repositories abstract all persistence so engine logic never touches SQLAlchemy directly.

1. **`SqlMatchRepo`** implements `MatchRepo` with methods to:

   * **Create** a new match
   * **Fetch** by `id`
   * **Update** status (`pending` → `active` → `completed`)
   * **Set** `start_timestamp`, `end_timestamp`, and `winner_character_id`&#x20;

2. **`SqlEventRepo`** implements `EventRepo` with:

   * **create\_match\_event(...)** – inserts a `MatchEvent` row each time an event fires
   * **get\_events\_for\_match(match\_id)** – to replay or audit a match’s log&#x20;

3. **`SqlCharacterRepo`** (and its base abstract) handles:

   * **Assigning** characters into a match (`assign_character_to_match`)
   * **Updating** alive/dead status (`update_character_status`)&#x20;

---

## 3. Engine Integration (core/engine.py)

`MatchEngine` drives the simulation and uses repos to persist every key step.

1. **Initialization**

   ```python
   self.match = match_repo.get_match_by_id(match_id)
   self.entry_fee = self.match.entry_fee
   self.kill_award_rate = self.match.kill_award_rate
   ```

   ­– loads settings from the `Match` row&#x20;

2. **Starting the Match**

   ```python
   match_repo.update_match_status(self.match_id, "active")
   match_repo.set_match_start_time(self.match_id)
   ```

   ­– flips status and stamps the start time&#x20;

3. **Per‐Round Event Loop**

   * For each event (primary or extra), after sampling and effect application, it calls:

     ```python
     event_repo.create_match_event(
         match_id, round_number, event_type,
         scenario_source, scenario_text, affected_ids
     )
     ```

     to append to `match_events` and the in-memory `match_log`&#x20;

4. **Ending the Match**

   * When one `Character` remains:

     1. Update player stats (wins, kills, SUI) via `PlayerRepo`
     2. Calculate payouts (protocol cut, kill awards, winner payout)
     3. Persist winner and status:

        ````python
        match_repo.set_match_winner(self.match_id, winner.id)
        match_repo.update_match_status(self.match_id, "completed")
        match_repo.set_match_end_time(self.match_id)
        ``` :contentReference[oaicite:18]{index=18}:contentReference[oaicite:19]{index=19}  
        ````

---

## 4. Typical Match Workflow

1. **Match Creation** (via CLI or main script)

   * `match = match_repo.create_match(...)`

2. **Character Purchases**

   * Simulate entry-fee payments and call `char_repo.assign_character_to_match(char.id, match.id)`.

3. **Run Engine**

   * `engine = MatchEngine(match.id, …); winner, log = engine.run_match(participants)`

4. **Audit & Extend**

   * Query `match_repo.get_match_by_id` for metadata.
   * Query `event_repo.get_events_for_match(match.id)` to reconstruct the round log.

---

## 5. Tips for Safe Modifications

* **Adding a field** to `Match` or `MatchEvent`:

  1. Update the ORM class in **models.py**.
  2. Run `init_db()` or adjust migrations so the column exists in SQLite.
  3. Expose new field in the corresponding repo method (e.g. in `create_match` or `create_match_event`).
  4. Modify `MatchEngine` to read/write the new property where appropriate—relying on repos for persistence.

* **Changing status semantics** (e.g., adding a “paused” state):

  * Extend `status` in the ORM default; update `SqlMatchRepo.update_match_status`; then insert corresponding calls in the engine at new transition points.

* **Extending events** (new event types or extra payload):

  * Add to `MatchEvent.event_type` enum-style handling.
  * In `MatchEngine._log_event`, include any extra fields in the call to `create_match_event`.
  * Update consumers (e.g., replay/Audit UIs) to handle the new data.

By following this mapping—from ORM definitions  through repository abstractions  to engine usage —a developer can safely trace, extend, or refactor any match-related feature without unintended side effects.
