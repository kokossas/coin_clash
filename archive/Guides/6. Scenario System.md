I’ve put together a comprehensive Scenario System Guide to help any new developer understand—and safely extend—the way scenarios power “Coin Clash.” It covers:

* **Definitions & Structure**: how scenarios are authored and represented
* **Draft-to-JSON Pipeline**: using `parse_scenarios.py` to convert `.md` drafts into canonical JSON
* **Runtime Loading**: how `core/scenario_loader.py` discovers, validates, and IDs scenario files
* **Engine Integration**: how `MatchEngine` selects, substitutes, and logs scenarios each round
* **Best Practices for Extensions**: adding or tweaking scenarios without disrupting logic

Feel free to copy this into your project wiki or README.

---

## 1. Definitions & Data Model

1. **Categories**
   Scenarios are grouped into six buckets:

   * `direct_kill`, `self`, `environmental`, `group`, `story` (non-lethal), and `comeback`&#x20;

2. **JSON Structure**
   Each category’s JSON file (e.g. `scenarios/direct_kill.json`) is a list of objects:

   ```json
   [
     { "text": "[Character A] spins her umbrella rifle and pops [Character B] off the diving board." },
     … 
   ]
   ```

   At load time, each item receives an `"id"` of the form `"{category}_{index:03d}"` .

3. **Placeholders**

   * Use `[Character A]`, `[Character B]`, etc., to indicate where characters are injected.
   * The engine counts unique placeholders to know how many participants to sample .

---

## 2. Draft-to-JSON Pipeline

`parse_scenarios.py` allows maintaining scenarios in Markdown drafts (`Scenarios.md` and `new_scenarios_draft.md`), then regenerating the JSON files:

1. **Category Mapping**
   Headlines like `### Direct Kills` map to `"direct_kill"`, etc., via `CATEGORY_MAP` .

2. **Parsing Logic**

   * Lines starting `* ` or numbered (`1. `) under each heading become scenario texts.
   * Strips list markers, bold titles, and trailing “(Item Find: …)” notes.

3. **Combining & Emitting**

   * Merges “existing” and “new” sets, then writes each non-empty category to `scenarios/{category}.json`.

> **When to run**: after editing drafts, execute `python parse_scenarios.py` to refresh `core/scenarios/*.json`.

---

## 3. Runtime Loading

The function `load_scenarios()` in `core/scenario_loader.py`:

1. **Discovery**
   Scans `core/scenarios/` for `*.json`, matching filenames against `EXPECTED_CATEGORIES` .

2. **Validation & ID Assignment**

   * Loads each JSON list, filters for objects with a string `"text"` field.
   * Adds `"id": "{category}_{i:03d}"` to each entry.

3. **Result**
   Returns a dict `{ category: [ {id, text}, … ], … }`, with warnings for any empty categories (except `comeback`) .

---

## 4. Engine Integration

Within `MatchEngine` (`core/engine.py`):

1. **Event-Type → Category**
   Maps round events to scenario lists via `EVENT_TYPE_TO_CATEGORY`:

   ````python
   EVENT_TYPE_TO_CATEGORY = {
     "direct_kill": "direct_kill",
     "self": "self",
     …,
     "extra_lethal": ["direct_kill","environmental"],
     …
   }
   ``` :contentReference[oaicite:12]{index=12}:contentReference[oaicite:13]{index=13}.

   ````

2. **Sampling & Substitution**

   * **Sample** one scenario (with replacement) from the chosen category’s pool.
   * **Count** placeholders via regex `r"\[Character ([A-Z])\]"`.
   * **Select** that many distinct characters from the alive (or dead, for comeback) pool.
   * **Substitute** placeholders 1:1 with each character’s `display_name` .

3. **Effects & Logging**

   * After substitution, the engine applies kills or revivals based on `event_type`.
   * Each event is persisted as a `MatchEvent` (storing `scenario_source=id`, `scenario_text`, and `affected_character_ids`) .
   * The same text is appended to the in-memory `match_log`.

4. **Special Rules**

   * When only two characters remain, skips any “group” or extra lethal events (enforced via early checks) .

---

## 5. Best Practices for Extension

* **Adding New Scenarios**

  1. Edit `new_scenarios_draft.md` (or your own draft) under the appropriate heading.
  2. Run `python parse_scenarios.py` to regenerate JSON.
  3. Ensure your text uses only `[Character A]`, `[Character B]`, etc., matching the number of participants you intend.

* **Direct JSON Edits**

  * You may directly add entries to `core/scenarios/*.json`; just include a `"text"` field.
  * If you need a custom ID, add an `"id"` key—otherwise it will be autogenerated at load time.

* **Testing Changes**

  * Because randomness is seedable (`SeedableRandom`), use a fixed seed to reproduce flows.
  * Confirm that placeholder counts match available characters; otherwise, events may be skipped with a warning.

* **Maintaining Category Integrity**

  * Don’t rename JSON files or categories without updating both `EXPECTED_CATEGORIES` and `EVENT_TYPE_TO_CATEGORY`.
  * If introducing a new event type, extend `EVENT_TYPE_TO_CATEGORY` and adjust `config.yaml` weights accordingly.

---

With this guide, a developer should confidently navigate scenario definitions, pipeline tools, and how these integrate into the match engine—allowing you to add new flavor without risking existing functionality. Let me know if anything needs more detail or examples!
