# /home/ubuntu/coin_clash/__main__.py

import logging
import os
import sys

# Add project root to path to allow imports like core.engine
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, project_root)

from core.config_loader import load_config
from core.scenario_loader import load_scenarios
from core.models import init_db, Player, Character
from core.repositories import (
    get_db,
    SqlPlayerRepo,
    SqlCharacterRepo,
    SqlMatchRepo,
    SqlEventRepo,
    SqlItemRepo
)
from core.engine import MatchEngine
from core.utils import SeedableRandom, get_next_character_name

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# --- Constants --- 
DEFAULT_SEED = 42 # set to None for random seed
CHARACTER_NAME_LIST_PATH = None # Using internal list from utils for now

def setup_repositories(db_session):
    """Initializes and returns all repository instances."""
    return {
        "player": SqlPlayerRepo(db_session),
        "character": SqlCharacterRepo(db_session),
        "match": SqlMatchRepo(db_session),
        "event": SqlEventRepo(db_session),
        "item": SqlItemRepo(db_session)
    }

def simulate_character_purchases(config: dict, players: list[Player], repos: dict, match_id: int, random_gen: SeedableRandom) -> list[Character]:
    """Simulates players purchasing characters for a match."""
    participants = []
    player_repo = repos["player"]
    char_repo = repos["character"]
    entry_fee = config["default_fee"] # Use default fee for simulation
    min_chars = config["chars_per_player_min"]
    max_chars = config["chars_per_player_max"]

    logger.info(f"Simulating character purchases for {len(players)} players...")

    total_fees_collected = 0
    protocol_cut_total = 0

    for player in players:
        num_chars_to_buy = random_gen.randint(min_chars, max_chars)
        logger.debug(f"Player {player.username} buying {num_chars_to_buy} characters.")

        # --- Fee Calculation & Protocol Cut --- 
        # Determine protocol cut rate based on number of characters bought *by this player*
        cut_rate_key = str(num_chars_to_buy)
        protocol_cut_rate = config["protocol_cut"].get(cut_rate_key)
        if protocol_cut_rate is None:
            # Fallback if specific number isn't in config (e.g., if max_chars > 3)
            # Use the rate for the highest defined tier or a default? Let's use highest defined.
            max_tier = max(config["protocol_cut"].keys(), key=int)
            protocol_cut_rate = config["protocol_cut"][max_tier]
            logger.warning(f"Protocol cut rate for {num_chars_to_buy} chars not found. Using rate for {max_tier} chars: {protocol_cut_rate}")
        
        fee_per_char = entry_fee
        total_cost = num_chars_to_buy * fee_per_char
        cut_amount = total_cost * protocol_cut_rate
        net_fee_to_pool = total_cost - cut_amount

        total_fees_collected += total_cost
        protocol_cut_total += cut_amount

        # --- Stubbed Payment --- 
        # Deduct fee from player balance (assuming they have enough for simulation)
        # In a real scenario, check balance before allowing purchase
        # player_repo.update_player_balance(player.id, -total_cost)
        logger.info(f"Player {player.username}: Charged {total_cost:.2f} SUI (stubbed). Protocol Cut: {cut_amount:.2f}. Added to pool: {net_fee_to_pool:.2f}")

        # --- Create Characters --- 
        for _ in range(num_chars_to_buy):
            char_name = get_next_character_name() # Get sequential name
            character = char_repo.create_character(name=char_name, owner_username=player.username)
            # Assign character to the match immediately
            char_repo.assign_character_to_match(character.id, match_id)
            participants.append(character)
            logger.debug(f"  Created Character: {character.display_name} (ID: {character.id}) for Match {match_id}")

    logger.info(f"Total Fees Collected: {total_fees_collected:.2f}, Total Protocol Cut: {protocol_cut_total:.2f}")
    # TODO: Store protocol_cut_total somewhere accessible to the engine's payout calculation?
    # Maybe update the Match object with this info?

    return participants

def run_simulation(seed: int = DEFAULT_SEED):
    """Runs a full game simulation."""
    logger.info("--- Starting Coin Clash Simulation --- ")
    random_gen = SeedableRandom(seed)
    logger.info(f"Using random seed: {seed}")

    # 1. Load Config & Scenarios
    try:
        config = load_config()
        logger.info("Configuration loaded successfully.")
        # Load scenarios directly from the JSON directory
        scenarios = load_scenarios(config["scenario_dir"])

    except (FileNotFoundError, ValueError, RuntimeError) as e:
        logger.error(f"Failed to load configuration or scenarios: {e}")
        return

    # 2. Initialize Database & Repositories
    try:
        init_db() # Ensure tables are created
        db_session = next(get_db())
        repos = setup_repositories(db_session)
        logger.info("Database and repositories initialized.")
    except Exception as e:
        logger.error(f"Failed to initialize database: {e}")
        if 'db_session' in locals(): db_session.close()
        return

    try:
        # 3. Initialize or Load Players
        num_players = config["num_players_default"]
        players = repos["player"].get_all_players(limit=num_players)
        if len(players) < num_players:
            logger.info(f"Found {len(players)} players. Creating {num_players - len(players)} new players...")
            for i in range(len(players), num_players):
                username = f"Player_{i+1:03d}"
                player = repos["player"].get_or_create_player(username)
                # Give some starting balance for simulation if needed
                # repos["player"].update_player_balance(player.id, 100.0) 
                players.append(player)
        logger.info(f"Loaded/Created {len(players)} players.")

        # 4. Create Match
        match = repos["match"].create_match(
            entry_fee=config["default_fee"],
            kill_award_rate=config["kill_award_rate_default"],
            start_method='cap', # Using cap for simulation
            start_threshold=1 # Start immediately after purchases for simulation
        )
        logger.info(f"Created Match ID: {match.id}")

        # 5. Simulate Purchases
        participants = simulate_character_purchases(config, players, repos, match.id, random_gen)
        if len(participants) < config["num_players_min"] * config["chars_per_player_min"]:
             logger.error(f"Not enough participants ({len(participants)}) created to start the match. Minimum required might be around {config['num_players_min'] * config['chars_per_player_min']}. Check config.")
             return
        logger.info(f"Total participants created: {len(participants)}")

        # 6. Initialize & Run Match Engine
        engine = MatchEngine(
            match_id=match.id,
            config=config,
            scenarios=scenarios,
            player_repo=repos["player"],
            character_repo=repos["character"],
            match_repo=repos["match"],
            event_repo=repos["event"],
            item_repo=repos["item"],
            random_seed=seed
        )
        
        logger.info("Starting match engine...")
        winner, match_log = engine.run_match(participants)

        # 7. Print Results
        logger.info("--- Simulation Complete --- ")
        print("\n===== Match Log =====")
        for line in match_log:
            print(line)
        print("=====================")

        if winner:
            logger.info(f"Final Winner: {winner.display_name}")
            # Display player stats post-match (optional)
            # winner_player = repos["player"].get_player_by_username(winner.owner_username)
            # print(f"Winner Stats ({winner_player.username}): Wins={winner_player.wins}, Kills={winner_player.kills}, Balance={winner_player.balance:.2f}")
        else:
            logger.warning("Match ended without a winner.")

    except Exception as e:
        logger.exception(f"An error occurred during simulation: {e}") # Use exception to get traceback
    finally:
        if 'db_session' in locals():
            db_session.close()
            logger.info("Database session closed.")

if __name__ == "__main__":
    # You can pass a seed as a command line argument
    sim_seed = int(sys.argv[1]) if len(sys.argv) > 1 else DEFAULT_SEED
    run_simulation(seed=sim_seed)

