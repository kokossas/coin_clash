Hereâ€™s a comprehensive guide to help anyone new to **Coin Clash** quickly find their way around the codebase, understand how everything connects, and safely extend it for new objectives without breaking existing functionality.

---

## ğŸ—‚ï¸ Project Structure

```text
.
â”œâ”€â”€ README.txt
â”œâ”€â”€ __main__.py
â”œâ”€â”€ config.yaml
â”œâ”€â”€ core/                       â† Core logic and infrastructure
â”‚   â”œâ”€â”€ config_loader.py       â† Loads & validates config.yaml
â”‚   â”œâ”€â”€ scenario_loader.py     â† Loads scenario JSON files into memory
â”‚   â”œâ”€â”€ models.py              â† SQLAlchemy ORM models (Player, Match, Characterâ€¦)
â”‚   â”œâ”€â”€ repositories.py        â† DB access layer (CRUD for matches, playersâ€¦)
â”‚   â”œâ”€â”€ engine.py              â† MatchEngine: the heart of the simulation
â”‚   â”œâ”€â”€ utils.py               â† Shared helper functions
â”‚   â””â”€â”€ __init__.py
â”œâ”€â”€ scenarios/                 â† Prebuilt event pools, one JSON per category
â”‚   â”œâ”€â”€ direct_kill.json
â”‚   â”œâ”€â”€ self.json
â”‚   â”œâ”€â”€ environmental.json
â”‚   â”œâ”€â”€ group.json
â”‚   â”œâ”€â”€ story.json
â”‚   â””â”€â”€ comeback.json
â”œâ”€â”€ new_scenarios_draft.md     â† Master Markdown list of all scenarios
â”œâ”€â”€ parse_scenarios.py         â† Converts new_scenarios_draft.md â†’ scenarios/*.json
â”œâ”€â”€ data/
â”‚   â””â”€â”€ coin_clash.db          â† SQLite file used by repositories
â”œâ”€â”€ tests/                     â† (Empty) place for unit tests
â””â”€â”€ requirements.txt
```

---

## ğŸ” Core Modules & How They Tie Together

1. **Configuration (`config_loader.py` + `config.yaml`)**

   * `config_loader.py` reads `config.yaml` and validates keys (entry-fees, kill-reward rates, event weights, extra-event chances, lethal modifiers, character-purchase caps, protocol cuts, etc.).
   * All â€œknobsâ€ to tune match behavior live in `config.yaml`â€”no hard-coding.

2. **Scenario Management (`scenario_loader.py` + `scenarios/*.json`)**

   * On startup, `scenario_loader` reads each category JSON into named pools (direct\_kill, environmental, story, group, self, comeback).
   * `parse_scenarios.py` + `new_scenarios_draft.md` exist so you can author scenarios in Markdown and regenerate JSON via:

     ```bash
     python parse_scenarios.py
     ```

3. **Data Models & Persistence (`models.py` + `repositories.py` + `data/coin_clash.db`)**

   * **Models** define ORM classes: `Player`, `Character`, `Match`, `EventRecord`, etc.
   * **Repositories** wrap SQLAlchemy sessions to CRUD players, matches, and record eventsâ€”so engine logic never writes SQL directly.
   * A lightweight SQLite DB keeps history; you can swap to another RDBMS by updating `config_loader` and SQLAlchemy connection string.

4. **Match Engine (`engine.py`)**

   * **Initialization**: seeded randomness for reproducibility (unit-test hook).
   * **Purchase Phase**: simulated or real players buy 1â€“3 characters at configured entry fee.
   * **Round Loop**: until only one character remains, pick next event category by weight, randomly select a scenario, apply its effect (kill, revive, cosmetic, non-lethal bonus).
   * **Economic Flow**: after each kill, award killer â€Š=â€Š `kill_award_rate` Ã— entry fee; at end, winner takes pool minus protocol cut tiered by number of chars sold.
   * **Extensibility Hooks**: no direct I/Oâ€”just pure functions that update model objects.

5. **Entry Point (`__main__.py`)**

   * Glues it all together:

     1. Load config & scenarios
     2. Optionally seed RNG
     3. Create simulated players (`num_players_default`)
     4. Run one match, printing events & final payouts

6. **Utilities (`utils.py`)**

   * Misc helpers: randomâ€choice wrappers, formatted text builders, date/time stamps, etc.

---

## ğŸ”§ How to Safely Extend or Modify

1. **Tuning & New Parameters**

   * **Always** add new â€œknobsâ€ in `config.yaml` and reference them via `config_loader`.
   * Avoid hardâ€coding defaults anywhere else.

2. **Adding a New Scenario Category**

   1. Create `scenarios/your_category.json` with a list of scenario objects.
   2. In `config.yaml` under `primary_event_weights:`, add your\_category with its weight.
   3. In `scenario_loader.py`, ensure you whitelist the new category.
   4. If the scenario has new effects, extend the engineâ€™s eventâ€handling switch to cover them.

3. **Altering Economic Rules**

   * Edit killâ€award rates, protocol cuts, entry fees in `config.yaml`.
   * For more complex payout logic, modify `engine.calculate_payouts()`â€”it consumes only model objects and config values.

4. **Changing Match Flow**

   * Round progression logic lives in `MatchEngine.run_match()` in `engine.py`.
   * You can insert new phases (e.g., looting) by adding new methods and updating the flow diagram there.

5. **Database Schema Changes**

   * Update `models.py` and run an Alembic (or similar) migration script against `coin_clash.db`.
   * Because all DB operations go through `repositories.py`, the engine code stays untouched.

6. **Integrating a Messaging Adapter**

   * Keep core logic pure: it returns plainâ€text event strings and model snapshots.
   * Write a separate â€œadapterâ€ layer (e.g. `telegram_adapter.py`) that calls `MatchEngine` and sends messages.
   * No need to modify `engine.py`â€”just import and reuse.

---

## âœ… Validation Checklist

Make sure your guide (and any changes) still cover all core game points:

* [ ] **Character Purchases**: 1â€“3 per player â†’ entry fees enforced (`chars_per_player_min/max` in config).
* [ ] **Match Start Conditions**: either time cap or player cap (configurable, though time-cap not yet implemented).
* [ ] **Random Eliminations**: from six scenario pools (direct\_kill, self, environmental, group, story, comeback).
* [ ] **Event Weights & Extra Events**: primary weights + non\_lethal\_story, extra\_lethal, comeback chances.
* [ ] **Kill Rewards & Payouts**: per-kill award rate config; winner takes pool minus protocol cut tiers.
* [ ] **Cosmetics & Items**: engine hooks for non-lethal scenario buffs (e.g. outfits, discounts).
* [ ] **Seedable Randomness**: `MatchEngine` accepts a seed for reproducible tests.
* [ ] **Extensibility Hooks**: modular designâ€”core logic independent of I/O or messaging.
* [ ] **Scenario Pipeline**: maintain scenario text in Markdown â†’ auto-generate JSON.
* [ ] **Persistence**: full match/event history stored via repositories into SQLite.
* [ ] **Tests**: directory ready for unit tests on edge cases (double-kill, empty revival pool, lethal modifiers).

---

With this map in hand, anyone handed the repository can:

1. **Locate** the bits they need to tweak (config vs. engine vs. scenarios).
2. **Understand** how data flows from config â†’ models â†’ engine â†’ DB â†’ output.
3. **Extend** safely by adding new YAML keys, scenario JSON, or adapter layersâ€”without touching unaffected code.

If youâ€™d like further detail on any piece (e.g. a deep dive into `MatchEngine.run_round()`), let me know!
